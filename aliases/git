# Aliases for GIT
# Created by LounisBou

# GLOBAL VARIABLES

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
ORANGE='\033[0;33m'
BLUE='\033[1;34m' # Light Blue
NC='\033[0m' # No Color

# List of workflow branches other than default branch (master|main)
work_branches=("staging")

# Reference branch for git-update-branch
ref_branch="main"

# Prefix
feature_prefix="feat-"
release_prefix="release/"
hotfix_prefix="hotfix/"
bugfix_prefix="bugfix/"
task_prefix="task/"
build_prefix="build-"

# Separator
feature_prefix_separator="-"

# Get git repository default branch
function gdefault-branch(){
    # Check if .git exists
    if [ ! -d .git ]; then
        # Do nothing
        return
    fi
    # Check if master branch exists
    if git show-ref --verify --quiet refs/heads/master; then
        # Set default branch to master
        default_branch="master"
    else
        # Set default branch to main
        default_branch="main"
    fi
    # Return default branch
    echo $default_branch
}

# Git create repo
function gcreate(){
    git init -b main
    git add .
    git commit -m "Initial commit"
}
function gcreate-remote(){
    # Create repo on github
    gh repo create $* --source=. --private --confirm --remote --push
}
# Git global
alias ga="git add $*"
alias gc="git commit -m $*"
alias gp="git push origin $*"
alias gpl="git pull"
alias gs="git status"
alias gcl="git clone $*"
# Git branch
alias gbr="git branch $*"
alias gbrd="git branch -d $*"
alias gbrD="git branch -D $*"
alias gbrm="git branch -m $*"
alias gbrM="git branch -M $*"
alias gbrv="git branch -v"
# Git log
function glg(){
    # Define variable nb_commits
    nb_commits=30
    # Check if $1 is not empty
    if [ ! -z "$1" ]
    then
        # Set $1 to nb_commits
        nb_commits=$1
    fi
    # Display git log
    git --no-pager log --graph --oneline --decorate --all -n $nb_commits
}
function gllc(){
    # Define variable nb_commits
    nb_commits=1
    # Check if $1 is not empty
    if [ ! -z "$1" ]
    then
        # Set $1 to nb_commits
        nb_commits=$1
    fi
    # Display git log
    git --no-pager log -$nb_commits
}
alias gdf="git diff"
# Git feature start
function gfs(){
    # Check if $1 is not empty
    if [ -z "$1" ]
    then
        # Display error message
        echo -e "${RED}Error: You must provide a feature name${NC}"
    else
        # Check if feature alternative prefix has been provided
        if [ ! -z "$2" ]
        then
            # Override feature prefix
            feature_prefix=$2${feature_prefix_separator}
        fi
        # Feature branch name
        feature_branch=${feature_prefix}$1
        # Checkout main branch
        git checkout $(gdefault-branch)
        # Pull main branch
        git pull
        # Create feature branch from main branch
        git checkout -b $feature_branch
    fi
}
# Git feature finish
function gff(){
    # Get current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # Workflow branches
    branches=($(gdefault-branch) ${work_branches[@]})
    # Check if current branch is in workflow branches
    if [[ " ${branches[@]} " =~ " ${current_branch} " ]]; then
        # Display error message
        echo -e "${RED}Error: You can't finish a workflow branch${NC}"
        return
    fi
    # Finish feature branch
    git checkout $(gdefault-branch)
    git pull
    git merge $current_branch
    git checkout $current_branch
    git push 
}

# Checkout
alias gco="git checkout $*"
function gcm(){
    # Checkout main branch
    git checkout $(gdefault-branch)
}
alias gcd="git checkout develop"
alias gct="git checkout tests"
alias gcp="git checkout prod"
alias gcpp="git checkout preprod"
alias gcs="git checkout staging"
function gcft(){
    # Checkout feature branch
    git checkout ${feature_prefix}${task_prefix}$*
}
function gcf(){
    # Check if feature name is provided
    if [ -z "$1" ]
    then
        # Display error message
        echo -e "${RED}Error: You must provide a feature name${NC}"
    else
        # Check if feature alternative prefix has been provided
        if [ ! -z "$2" ]
        then
            # Override feature prefix
            feature_prefix=$2${feature_prefix_separator}
        fi
        # Checkout feature branch
        git checkout ${feature_prefix}$*
    fi
}
function gcr(){
    # Checkout release branch
    git checkout ${release_prefix}$*
}
function gch(){
    # Checkout hotfix branch
    git checkout ${hotfix_prefix}$*
}
function gcb(){
    # Checkout bugfix branch
    git checkout ${bugfix_prefix}$*
}
# Delete branch
function grm(){
    # Delete branch
    git branch -d $*
}
# Delete remote branch
function grm-remote(){
    # Delete remote branch
    git push origin --delete $*
}
# Delete current branch
function grmc(){
    # Get current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # Checkout to default branch
    git checkout $(gdefault-branch)
    # Delete current branch
    git branch -d $current_branch
}
# Delete remote current branch
function grmc-remote(){
    # Get current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # Delete remote current branch
    git push origin --delete $current_branch
}
# Stash
alias gst="git stash"
alias gstl="git stash list"
alias gstp="git stash pop"
alias gstc="git stash clear"
# Merge
function gmf(){
    # Get current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # Checkout on feature branch
    git checkout ${feature_prefix}$*
    # Update feature branch
    git pull
    # Checkout on current branch
    git checkout $(current_branch)
    # Merge feature branch
    git merge ${feature_prefix}$* -m "Merge ${feature_prefix}$* in ${current_branch}"
}
function gmft(){
    # Get current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # Checkout on feature task branch
    git checkout ${feature_prefix}${task_prefix}$*
    # Update feature task branch
    git pull
    # Checkout on current branch
    git checkout $(current_branch)
    # Merge feature task branch
    git merge ${feature_prefix}${task_prefix}$* -m "Merge ${feature_prefix}${task_prefix}$* in ${current_branch}"
}
function gmergin(){
    # Retrieve current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # Go to $1 branch
    git checkout $1
    # Merge current branch in $1 branch
    git merge $(current_branch) -m "Merge ${current_branch} in $1"
    # git add all
    git add .
    # git commit
    git commit -m "Merge ${current_branch} in $1"
    # Go back to current branch
    git checkout $(current_branch)
}
alias gmt="git mergetool"
# Get laster tag for branch
function gtag(){
    # Check if $1 is not empty
    if [ -z "$1" ]
    then
        # Set default branch name
        branch_name="$(gdefault-branch)"
    else
        # Set branch name
        branch_name=$1
    fi
    # Get last tag for current branch
    last_tag=$(git describe --tags `git rev-list --tags --max-count=1 $branch_name`)
    # Display last tag
    echo -e "${GREEN}Last tag for ${branch_name} branch is : ${last_tag} ${NC}"
}
# Push tag 
function gpt(){
    # Push all local tags
    git push origin --tags
    # Message user to call git after mep
    echo -e "${ORANGE}WARNING : You should call method 'git-after-mep' to update $(gdefault-branch) ${work_branch} branches ${NC}"
}
# Update $(gdefault-branch) ${work_branch} branch
function git-update(){
    # Retrieve current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # Fetch all branches
    git fetch --all
    # List of branches to update
    branches=($(gdefault-branch) ${work_branches[@]})
    # Loop on branches
    for branch in "${branches[@]}"
    do
        # Checkout branch
        git checkout $branch
        # Pull branch
        git pull
    done
    # Checkout current branch
    git checkout $current_branch
    # Pull current branch
    git pull
}
# Update current branch by merging ref branch on it
function git-update-branch(){
    # Retrieve current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # Branch to update
    branches=($(gdefault-branch) ${work_branches[@]})
    # Checkout ref branch
    git checkout $ref_branch
    # Pull branch
    git pull
    # Checkout current branch
    git checkout $current_branch
    # Pull current branch
    git pull
    # Merge ref branch in current branch
    git merge $ref_branch
    # Check if there is a conflict
    git diff --check
    # Ask user if he wants to continue
    read REPLY"?Do you want to continue ? (y/n) "
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Commit merge
        git commit -m "Merge $ref_branch in $current_branch"
        # Push current branch
        git push
    fi
}
# After MEP
function git-after-mep(){
    # Retrieve current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # List of branches to update
    branches=($(gdefault-branch) ${work_branches[@]})
    # Loop on branches
    for branch in "${branches[@]}"
    do
        # Checkout branch
        git checkout $branch
        # Merge current branch in branch
        git merge $current_branch -m "Merge $current_branch in $branch"
        # Push branch
        git push
    done
    # Checkout current branch
    git checkout $current_branch
    # Push current branch
    git push
}
# Push current branch on a specific branch
function gpushon(){
    # Retrieve branch to push on
    branch_to_push_on=$1
    # Retrieve current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # Add all files to commit
    ga .
    # Check if there is a commit message
    if [ -z "$2" ]
    then
        # Set default commit message
        commit_message="Push $current_branch on $branch_to_push_on"
    else
        # Set commit message
        commit_message=$2
    fi
    # Commit with message
    gc $commit_message
    # Push current branch
    gp $current_branch
    # Merge current branch in branch to push on
    gmergin $branch_to_push_on
    # Update $(gdefault-branch) ${work_branch[@]} branches
    git-update
    # Push on branch to push on
    gp $branch_to_push_on
}
# Manage merge conflicts
function git-conflicts(){
    # Retrieve current branch name
    current_branch=$(git branch | grep \* | cut -d ' ' -f2)
    # Check if there is a conflict
    git diff --check
    # Ask user if he wants to continue
    read REPLY"?Do you want to continue ? (y/n) "
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Commit merge
        git commit -m "Merge $ref_branch in $current_branch"
        # Push current branch
        git push
    fi
}
# Git rollback $1 commit
function git-rollback(){
    # Check if $1 is not empty
    if [ -z "$1" ]
    then
        # Set default number of commits
        nb_commits=1
    else
        # Set number of commits
        nb_commits=$1
    fi
    # Log the last $nb_commits commit(s)
    git --no-pager log --oneline --max-count=$nb_commits
    # Ask user if he is sure to rollback last commit
    read REPLY"?Do you want to rollback last $nb_commits commit(s) ? (y/n) "
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Rollback last commit
        git reset --hard HEAD~$nb_commits
    else
        echo "Rollback aborted"
    fi
}
# Git rollback $1 commit
function git-log(){
    # Check if $1 is not empty
    if [ -z "$1" ]
    then
        # Set default number of commits
        nb_commits=1
    else
        # Set number of commits
        nb_commits=$1
    fi
    # Log the last $nb_commits commit(s)
    git --no-pager log --oneline --max-count=$nb_commits
}
# Git checkout to commit
function git-move-head(){
    # Get a list of commits using git log --oneline
    commit_list=$(git log --oneline)

    # If no commits are found, exit the script
    if [ -z "$commit_list" ]; then
        echo "No commits found."
        exit 1
    fi
    
    # Initialize an empty array
    commits=()

    # Read commit list line by line into an array
    while IFS= read -r line; do
        commits+=("$line")
    done <<< "$commit_list"

    # Use select to create a menu for checking out a commit
    PS3="Please select a commit to checkout (or 'q' to quit): "
    select commit_option in "${commits[@]}" "Quit"; do
        if [[ "$REPLY" = "q" ]] || [[ "$REPLY" = "Quit" ]]; then
            echo "Exiting..."
            break
        elif [[ -n "$commit_option" ]] && [[ "$REPLY" -le ${#commits[@]} ]]; then
            commit_hash=$(echo "$commit_option" | awk '{print $1}')
            echo "Checking out commit $commit_hash..."
            git checkout "$commit_hash"
            break
        else
            echo "Invalid option. Please try again."
        fi
    done
}   
# Infos
alias ginfo="git config --list"